% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/accordion.R
\name{accordion}
\alias{accordion}
\title{Automatically annotating and interpreting single-cell populations with the built-in Cell Marker Accordion database}
\usage{
accordion(
  data,
  cluster_info = "seurat_clusters",
  assay = "RNA",
  database = NULL,
  CL_celltypes = NULL,
  species = "Human",
  tissue = NULL,
  root_cell_types = NULL,
  include_descendants = FALSE,
  ECs_threshold = NULL,
  SPs_threshold = NULL,
  log2FC_threshold = NULL,
  min_n_marker = 5,
  max_n_marker = 30,
  combined_score_quantile_threshold = NULL,
  annotation_resolution = "cluster",
  cluster_score_quantile_threshold = 0.75,
  allow_unknown = TRUE,
  annotation_name = "accordion",
  include_detailed_annotation_info = TRUE,
  condition_group_info = NULL,
  celltype_group_info = NULL,
  group_markers_by = "celltype_cluster",
  top_cell_score_quantile_threshold = 0.9,
  n_top_celltypes = 5,
  n_top_markers = 5,
  top_marker_score_quantile_threshold = 0.75,
  plot = TRUE,
  color_by = "cell_type"
)
}
\arguments{
\item{data}{Either a  Seurat object (version 4 or 5) or a raw or normalized
count matrix with genes on rows and cells on columns. If raw counts are
provided, data are log-normalized exploiting the NormalizeData() function
from the Seurat package.}

\item{cluster_info}{in case \code{data} is a Seurat object,
\code{cluster_info} should be need to be a character string specifying the
name of the column in the metadata that contains cluster ids; if
\code{data} is a count matrix, \code{cluster_info} should be need to be a
data frame or data table containing cluster identity for each cell. The
data frame or data table should contain at least two columns, one  named
“cell”, which specifies cell id’s, and one named “cluster”, which specifies
the clustering id’s for each cell. This parameter is necessary only when
the input is a count matrix and only if the \code{annotation_resolution}
parameter is set to “cluster”. Default is “seurat_clusters”.}

\item{assay}{Character string specifying the Assay of the Seurat object. This
parameter is necessary only  in case \code{data} is a Seurat object.
Default is “RNA”.}

\item{database}{Data table returns from the "marker_database_integration()" function.
By default is set to NULL and the Accordion database is used for the annotation.}

\item{CL_celltypes}{Character string or character string vector specifying the
cell types to annotate. Run the function "list_celltypes()"
to obtain the available cell types. If this parameter is not specified,
all cell types present in the Accordion database are used for the annotation.
Default is NULL.}

\item{species}{Character string or character string vector specifying the
species. Currently, either “Human” and/or “Mouse” are supported. If
multiple species are selected, marker genes are merged together. Default is
“Human”.}

\item{tissue}{Character string or character string vector specifying the tissue.
Run the function "list_tissues()" to obtain the available tissues. If multiple
tissues are selected cell types and markers from the selected tissues
are aggregated. If NULL, all tissues are considered. Default is NULL.}

\item{root_cell_types}{Character string or vector specifying one or more cell types
to be used as root terms. Only the descendant cell types of the specified roots
will be use for the annotation, excluding the root terms themselves. Default
is NULL.}

\item{include_descendants}{Logical value indicating whether include all the
tissues that are descendants of the selected tissue(s) according to the uberon
ontology. If TRUE,cell types and markers from the selected tissues and their
descendants are aggregated. Default is FALSE.}

\item{ECs_threshold}{Integer value (currently in (1,17))
specifying the minimum evidence consistency score (ECs) for each
marker. Only markers >= this threshold are kept. If NULL, no filter is
applied. Default is NULL.}

\item{SPs_threshold}{numeric value in (0,1) specifying the
minimum specificity score (SPs) for each marker. Only markers <= this threshold
are kept. If  NULL, no filter is applied. Default is NULL.}

\item{log2FC_threshold}{numeric value specifying the
minimum log2FC threshold for each marker reporting this information.
Only markers <= this threshold or without any log2FC
are kept. If  NULL, no filter is applied. Default is NULL.}

\item{min_n_marker}{Integer value specifying the minimum number of markers to
keep for each cell type. Only cell types with a number of markers >= this
threshold are kept.  Default is 5.}

\item{max_n_marker}{Integer value specifying the maximum number of markers to
keep for each cell type. For the selection, markers are ranked according to
their combined score, obtained by multiplying evidence consistency score
and specificity score. If  NULL, no filter is applied. Default is 30.}

\item{combined_score_quantile_threshold}{numeric value in (0,1) specifying
the combined score quantile threshold. For the selection, markers are
ranked according to their combined score,  obtained by multiplying evidence
consistency score and specificity score. Only markers >  the
quantile_threshold are kept. If  NULL, no filter is applied. Default is
NULL.}

\item{annotation_resolution}{Character string or character string vector
specifying the resolution of the annotation. Either “cluster” and/or “cell”
are supported. Default is “cluster”.}

\item{cluster_score_quantile_threshold}{numeric value in (0,1) specifying the
cluster score quantile threshold. For each cell a score specific for each
cell type is computed. To annotate a cluster cl, for each cell type the
\code{cluster_score_quantile_threshold} is computed across cells belonging
to that cluster and the cell type with the maximum score is then assigned
to the cluster cl. Default is 0.75.}

\item{allow_unknown}{Logical value indicating whether to allow cells or
clusters to be labeled as “unknown”. If it is set to TRUE, cells or
clusters with negative scores are assigned to the “unknown” category.
Default is TRUE.}

\item{annotation_name}{Character string specifying the name of the column
in either the metadata of the input Seurat object or in the input
\code{cluster_info} where the annotation will be stored. Per cluster and
per cell annotation results will be stored in the
\code{annotation_name}_per_cluster and \code{annotation_name}_per_cell
columns respectively.
If \code{include_detailed_annotation_info} parameter is set to TRUE, the
detailed information the stored in a list named \code{annotation_name}.
Default is “accordion”.}

\item{include_detailed_annotation_info}{Logical value indicating whether to
store information on the top cell types and markers in the output. If TRUE,
a nested list named \code{annotation_name} is created. If \code{resolution_annotation}
is set to “cluster” and/or “cell, sublists named “cluster_resolution”
and/or “cell_resolution” are then added. Inside the sublist
“detailed_annotation_info” the \code{n_top_markers} markers, group by
\code{group_markers_by} and the \code{n_top_celltypes} cell types are then
included. If a Seurat object is provided as input the list is stored in the
misc slot of the object (object@misc@\code{annotation_name}). If the input is a count
matrix, the list is returned in the final output. Default is TRUE.}

\item{condition_group_info}{in case \code{data} is a Seurat object,
\code{condition_group_info} should be need to be a character string specifying the
name of the column in the metadata that contains condition ids for each cell;
if \code{data} is a count matrix, \code{condition_group_info} should be need to be a
data frame or data table containing condition identity for each cell. The
data frame or data table should contain at least two columns, one  named
“cell”, which specifies cell id’s, and one named “condition”, which specifies
the condition id’s for each cell.  Default is NULL.}

\item{celltype_group_info}{in case \code{data} is a Seurat object,
\code{celltype_group_info} should be need to be a character string specifying the
name of the column in the metadata that contains cell types ids for each cell;
if \code{data} is a count matrix, \code{celltype_group_info} should be need to be a
data frame or data table containing cell types identity for each cell. The
data frame or data table should contain at least two columns, one  named
“cell”, which specifies cell id’s, and one named “CL_celltype”, which specifies
the cell types for each cell.  Default is NULL.}

\item{group_markers_by}{Character string or character string vector
specifying the classification of marker genes. It possible to retrieve
\code{n_top_markers} marker genes for each cell type identified with
cluster ("celltype_cluster") or cell ("celltype_cell") resolution;
\code{n_top_markers} marker genes per cluster ("cluster") or per cell
("cell") can be also obtained. Additionally, by setting \code{group_markers_by}
to "score_cell", the \code{n_top_markers} marker genes only for
cells with a score greater than
\code{top_cell_score_quantile_threshold} are retrieved.
Either "celltype_cluster", "celltype_cell","cluster", "cell" or "score_cell".
Default is "celltype_cluster".}

\item{top_cell_score_quantile_threshold}{numeric value in (0,1) specifying
the cell score quantile threshold. For each cell type a score specific for
each cell is computed. The \code{top_cell_score_quantile_threshold} is
computed across cells belonging to the same cell type, and only
cells with a score greater than the \code{top_cell_score_quantile_threshold}
are kept. This parameter is necessary only when \code{group_markers_by}
is set to "score_cell". Default is 0.90.}

\item{n_top_celltypes}{Integer value specifying the number of the top cell
types to be included in the output for each cluster and cell depending on
the selected \code{annotation_resolution} parameter Default is 5.}

\item{n_top_markers}{Integer value specifying the number of the top markers
to be included in the output for each cell type, cluster or cell depending
on the selected \code{annotation_resolution} and \code{group_markers_by}
parameters. Default is 5.}

\item{top_marker_score_quantile_threshold}{numeric value in (0,1) specifying
the marker score quantile threshold. For each marker a score specific for
each cell is computed. To identify the \code{n_top_markers} for a cluster
cl or a cell type ct, the \code{top_marker_score_quantile_threshold} is
computed across cells belonging to that cluster or labeled as ct, and the
\code{n_top_markers} with the maximum score are reported. Default is 0.75.}

\item{plot}{Logical value indicating whether to store plots displaying
detailed annotation information.  This parameter can be set to TRUE only
when \code{include_detailed_annotation_info} is set to TRUE. If TRUE,
lollipop plots displaying the top \code{n_top_markers} group by
\code{group_markers_by} and top \code{n_top_celltypes} for each
\code{annotation_resolution} together with the cell types hierarchies based
on the cell ontology structure are stored in the \code{annotation_name} list. Default
is TRUE.}

\item{color_by}{Character string specifying if the plot reporting the top
cell types for each cluster/cell is colored based on the assigned cell type
("cell_type") or on cluster id ("cluster"). Default is "cell_type.}
}
\value{
A Seurat object or a list
}
\description{
This function performs cell types annotation exploiting the built-in Accordion gene marker database.
It takes in input either a Seurat object or a raw or normalized count matrix and return in output
the cell types assignment and the detailed information of the annotation results (added to the Seurat object or as a list).
}
\details{
If a Seurat object was provided in input, the function returns the
Seurat object with markers-based scaled data in the scale.data slot and cell
types annotation results in the metadata.
If \code{include_detailed_annotation_info} and
\code{plot} were set to TRUE, a
list containing cell types and markers information, together with ggplot
objects, is stored in the “misc@\code{annotation_name}” slot. If a count matrix was
provided in input, the function returns a list containing the following
elements:

\describe{
\item{"scaled_matrix":}{normalized and scaled expression matrix;}
}
If \code{annotation_resolution} is set to “cell”:
\describe{
\item{"cell_annotation":}{data table containing cell types annotation results for each cell;}
}
If \code{annotation_resolution} is set to “cluster”:
\describe{
\item{"cluster_annotation":}{data table containing cell types annotation results for each cell;}
}
If \code{include_detailed_annotation_info} is set to TRUE:
\describe{
\item{"\code{annotation_name}":}{list containing detailed information of cell types annotation.}
}
}
